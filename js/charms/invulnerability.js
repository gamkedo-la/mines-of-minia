export { InvulnerabilityCharm };

import { Assets } from '../base/assets.js';
import { Events } from '../base/event.js';
import { OverlaySystem } from '../systems/overlaySystem.js';
import { TurnSystem } from '../systems/turnSystem.js';
import { Charm } from './charm.js';

class InvulnerabilityCharm extends Charm {
    // STATIC VARIABLES ----------------------------------------------------
    static dfltApTL = 100;

    static applied(e) {
        return e.charms && e.charms.some((v) => v.constructor.name === this.name);
    }

    // CONSTRUCTOR/DESTRUCTOR ----------------------------------------------
    constructor(spec={}) {
        super(spec);
        this.description = 'invulnerability charm';
        // number of action points to persist charm
        this.apTL = spec.apTL || this.constructor.dfltApTL;
        // number of action points elapsed
        this.elapsed = 0;
        this.vfx = spec.vfx || Assets.get('vfx.invulnerability', true);
        // -- events
        this.onTurnDone = this.onTurnDone.bind(this);
    }
    destroy() {
        this.unlink();
    }

    as_kv() {
        return Object.assign({}, super.as_kv(), {
            apTl: this.apTl,
            elapsed: this.elapsed,
        });
    }

    // EVENT HANDLERS ------------------------------------------------------
    onTurnDone(evt) {
        let ap = evt.points || 0;
        this.elapsed += ap;
        if (this.elapsed >= this.apTL) {
            console.log(`-- ${this} expired from ${this.actor}`);
            this.unlink();
        }
    }

    // METHODS -------------------------------------------------------------
    link(actor) {
        super.link(actor);
        Events.listen(TurnSystem.evtDone, this.onTurnDone);
        if (this.vfx) Events.trigger(OverlaySystem.evtNotify, { actor: actor, which: 'vfx', vfx: this.vfx, destroyEvt: 'invulnerable.done'});
    }

    unlink() {
        let actor = this.actor;
        super.unlink();
        if (actor) actor.evt.trigger('invulnerable.done', {actor: actor});
        Events.ignore(TurnSystem.evtDone, this.onTurnDone);
    }

}